<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>THREE.js Cube</title>
    <script src="objectDefaultFiles/gl-worker.js"></script>
<!--    <script src="gl-worker.js"></script>-->
</head>
<body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';

      let camera, scene, renderer, realRenderer;
      let mesh;

      var threejsContainerObj;
      var realityInterface;

      var isProjectionMatrixSet = false;

      var rendererWidth = screen.height;
      var rendererHeight = screen.width;
      var aspectRatio = rendererWidth / rendererHeight;

      window.addEventListener('load', function() {
        realityInterface = new RealityInterface();
        realityInterface.useWebGlWorker();
      });
      
      // animate();

      function main() {

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        realRenderer = new THREE.WebGLRenderer( { alpha: true } );
        realRenderer.setPixelRatio( window.devicePixelRatio );
        realRenderer.setSize( rendererWidth, rendererHeight );
        // document.body.appendChild( realRenderer.domElement );
        realGl = realRenderer.getContext();

        renderer = new THREE.WebGLRenderer({context: gl});
        renderer.setSize(rendererWidth, rendererHeight);

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        const texture = new THREE.TextureLoader().load( 'textures/crate.gif' );

        const geometry = new THREE.BoxGeometry( 200, 200, 200 );
        const material = new THREE.MeshBasicMaterial( { map: texture } );

        mesh = new THREE.Mesh( geometry, material );
        threejsContainerObj.add( mesh );

        // renderer = new THREE.WebGLRenderer( { antialias: true } );
        // renderer.setPixelRatio( window.devicePixelRatio );
        // renderer.setSize( window.innerWidth, window.innerHeight );
        // document.body.appendChild( renderer.domElement );

        //

        // window.addEventListener( 'resize', onWindowResize );

        initRealityInterface();
      }
      window.main = main;
      
      function initRealityInterface() {
        realityInterface.subscribeToMatrix();
        realityInterface.setFullScreenOn();

        // whenever we receive new matrices from the editor, update the 3d scene
        realityInterface.addMatrixListener(renderScene);

        realityInterface.setMoveDelay(10);

        realityInterface.getScreenDimensions(function(width, height) {
          document.body.width = width + 'px';
          document.body.height = height + 'px';
          rendererWidth = width;
          rendererHeight = height;
          renderer.setSize( rendererWidth, rendererHeight );

          realityInterface.changeFrameSize(width, height);
        });
      }

      // function onWindowResize() {
      //
      //   camera.aspect = window.innerWidth / window.innerHeight;
      //   camera.updateProjectionMatrix();
      //
      //   renderer.setSize( window.innerWidth, window.innerHeight );
      //
      // }

      function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
        array[1], array[5], array[9], array[13],
        array[2], array[6], array[10], array[14],
        array[3], array[7], array[11], array[15]
        );
      }

      let lastProjectionMatrix = null;
      let lastModelViewMatrix = null;

      function renderScene(modelViewMatrix, projectionMatrix) {
        lastProjectionMatrix = projectionMatrix;
        lastModelViewMatrix = modelViewMatrix;
      }

      let _then = 0;
      let done = false;

      // Draw the scene repeatedly
      render = function(_now) {
        // now *= 0.001;  // convert to seconds
        // const deltaTime = now - then;
        // then = now;

        // cube.rotation.x -= 0.2 * deltaTime;
        // cube.rotation.y -= 0.2 * deltaTime;

        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && lastProjectionMatrix && lastProjectionMatrix.length === 16) {
          setMatrixFromArray(camera.projectionMatrix, lastProjectionMatrix);
          isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet && lastModelViewMatrix && lastModelViewMatrix.length === 16) {
          // don't turn into else statement, both can happen
          // update models with newest values from the reality editor
          mesh.rotation.x += 0.005; // slow rotation, for aesthetic effect
          mesh.rotation.y += 0.01;
          // update model view matrix
          setMatrixFromArray(threejsContainerObj.matrix, lastModelViewMatrix);
          // render the scene
          threejsContainerObj.visible = true;

          if (renderer && scene && camera) {
            renderer.render(scene, camera);
            if (done && realGl) {
              for (let proxy of proxies) {
                proxy.__uncloneableObj = null;
                delete proxy.__uncloneableObj;
              }
              proxies = [];
              realRenderer.dispose();
              realRenderer.forceContextLoss();
              // realRenderer.context = null;
              realRenderer.domElement = null;
              realRenderer = null;
              realGl = null;
            }
            done = true;
          }
        }
      };
      
      window.render = render;

    </script>
</body>
</html>
